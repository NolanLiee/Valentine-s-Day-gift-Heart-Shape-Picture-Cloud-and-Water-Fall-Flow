<!DOCTYPE html>
<html>
<head>
  <title>致周怡萍</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="container">
    <!-- 动态爱心画布（初始显示） -->
    <canvas id="pinkboard" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;"></canvas>
    
    <!-- 主画布（初始隐藏） -->
    <canvas id="heartCanvas" style="opacity: 0; transition: opacity 1s ease;"></canvas>
    <div class="status"></div>
  </div>
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="script.js"></script>
</body>
</html>

<style>
body {
  margin: 0;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: #f0f2f5;
  font-family: 'Arial', sans-serif;
  overflow: hidden;
}
.container {
  position: relative;
  width: 80%;
  max-width: 1200px;
  height: 100%;
}
#heartCanvas {
  width: 100%;
  height: 100%;
  background: #fff;
  cursor: pointer;
  display: block;
}
.status {
  text-align: center;
  margin-top: 20px;
  color: #fc85fc;
  font-weight: bold;
  position: absolute;
  bottom: 20px;
  left: 0;
  right: 0;
  z-index: 20;
  opacity: 0;
  transition: opacity 1s ease;
}
</style>

<script>
// === 第一部分：动态爱心动画（持续5秒）===
var heartAnimation = (function() {
  var settings = {
    particles: {
      length: 500,
      duration: 2,
      velocity: 50,
      effect: -0.75,
      size: 30,
    }
  };
  
  // 兼容性处理
  (function() {
    var b = 0;
    var c = ["ms", "moz", "webkit", "o"];
    for (var a = 0; a < c.length && !window.requestAnimationFrame; ++a) {
      window.requestAnimationFrame = window[c[a] + "RequestAnimationFrame"];
      window.cancelAnimationFrame = window[c[a] + "CancelAnimationFrame"] || window[c[a] + "CancelRequestAnimationFrame"]
    }
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function(h, e) {
        var d = new Date().getTime();
        var f = Math.max(0, 16 - (d - b));
        var g = window.setTimeout(function() {
          h(d + f)
        }, f);
        b = d + f;
        return g
      }
    }
    if (!window.cancelAnimationFrame) {
      window.cancelAnimationFrame = function(d) {
        clearTimeout(d)
      }
    }
  })();
  
  // Point类
  var Point = (function() {
    function Point(x, y) {
      this.x = (typeof x !== 'undefined') ? x : 0;
      this.y = (typeof y !== 'undefined') ? y : 0;
    }
    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };
    Point.prototype.length = function(length) {
      if (typeof length == 'undefined')
        return Math.sqrt(this.x * this.x + this.y * this.y);
      this.normalize();
      this.x *= length;
      this.y *= length;
      return this;
    };
    Point.prototype.normalize = function() {
      var length = this.length();
      this.x /= length;
      this.y /= length;
      return this;
    };
    return Point;
  })();
  
  // Particle类
  var Particle = (function() {
    function Particle() {
      this.position = new Point();
      this.velocity = new Point();
      this.acceleration = new Point();
      this.age = 0;
    }
    Particle.prototype.initialize = function(x, y, dx, dy) {
      this.position.x = x;
      this.position.y = y;
      this.velocity.x = dx;
      this.velocity.y = dy;
      this.acceleration.x = dx * settings.particles.effect;
      this.acceleration.y = dy * settings.particles.effect;
      this.age = 0;
    };
    Particle.prototype.update = function(deltaTime) {
      this.position.x += this.velocity.x * deltaTime;
      this.position.y += this.velocity.y * deltaTime;
      this.velocity.x += this.acceleration.x * deltaTime;
      this.velocity.y += this.acceleration.y * deltaTime;
      this.age += deltaTime;
    };
    Particle.prototype.draw = function(context, image) {
      function ease(t) {
        return (--t) * t * t + 1;
      }
      var size = image.width * ease(this.age / settings.particles.duration);
      context.globalAlpha = 1 - this.age / settings.particles.duration;
      context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
    };
    return Particle;
  })();
  
  // ParticlePool类
  var ParticlePool = (function() {
    var particles,
            firstActive = 0,
            firstFree = 0,
            duration = settings.particles.duration;
 
    function ParticlePool(length) {
      particles = new Array(length);
      for (var i = 0; i < particles.length; i++)
        particles[i] = new Particle();
    }
    ParticlePool.prototype.add = function(x, y, dx, dy) {
      particles[firstFree].initialize(x, y, dx, dy);
      firstFree++;
      if (firstFree == particles.length) firstFree = 0;
      if (firstActive == firstFree) firstActive++;
      if (firstActive == particles.length) firstActive = 0;
    };
    ParticlePool.prototype.update = function(deltaTime) {
      var i;
      if (firstActive < firstFree) {
        for (i = firstActive; i < firstFree; i++)
          particles[i].update(deltaTime);
      }
      if (firstFree < firstActive) {
        for (i = firstActive; i < particles.length; i++)
          particles[i].update(deltaTime);
        for (i = 0; i < firstFree; i++)
          particles[i].update(deltaTime);
      }
      while (particles[firstActive].age >= duration && firstActive != firstFree) {
        firstActive++;
        if (firstActive == particles.length) firstActive = 0;
      }
    };
    ParticlePool.prototype.draw = function(context, image) {
      if (firstActive < firstFree) {
        for (i = firstActive; i < firstFree; i++)
          particles[i].draw(context, image);
      }
      if (firstFree < firstActive) {
        for (i = firstActive; i < particles.length; i++)
          particles[i].draw(context, image);
        for (i = 0; i < firstFree; i++)
          particles[i].draw(context, image);
      }
    };
    return ParticlePool;
  })();
  
  // 主函数
  var animationId = null;
  
  function startAnimation(canvas) {
    var context = canvas.getContext('2d'),
            particles = new ParticlePool(settings.particles.length),
            particleRate = settings.particles.length / settings.particles.duration,
            time;
    
    // 获取爱心点位
    function pointOnHeart(t) {
      return new Point(
        160 * Math.pow(Math.sin(t), 3),
        130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
      );
    }
    
    // 创建粒子图像
    var image = (function() {
      var canvas = document.createElement('canvas'),
              context = canvas.getContext('2d');
      canvas.width = settings.particles.size;
      canvas.height = settings.particles.size;
      
      function to(t) {
        var point = pointOnHeart(t);
        point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;
        point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;
        return point;
      }
      
      context.beginPath();
      var t = -Math.PI;
      var point = to(t);
      context.moveTo(point.x, point.y);
      while (t < Math.PI) {
        t += 0.01;
        point = to(t);
        context.lineTo(point.x, point.y);
      }
      context.closePath();
      context.fillStyle = '#ea80b0';
      context.fill();
      var image = new Image();
      image.src = canvas.toDataURL();
      return image;
    })();
    
    // 渲染函数
    function render() {
      animationId = requestAnimationFrame(render);
      
      var newTime = new Date().getTime() / 1000,
              deltaTime = newTime - (time || newTime);
      time = newTime;
      
      context.clearRect(0, 0, canvas.width, canvas.height);
      
      // 创建新粒子
      var amount = particleRate * deltaTime;
      for (var i = 0; i < amount; i++) {
        var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
        var dir = pos.clone().length(settings.particles.velocity);
        particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
      }
      
      particles.update(deltaTime);
      particles.draw(context, image);
    }
    
    // 调整画布大小
    function onResize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    window.addEventListener('resize', onResize);
    
    // 开始渲染
    onResize();
    render();
    
    return {
      stop: function() {
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
          window.removeEventListener('resize', onResize);
        }
      },
      resize: onResize
    };
  }
  
  return {
    start: startAnimation
  };
})();

// === 第二部分：你的爱心图云和瀑布流代码（添加海浪效果）===
// === 新增：配置图片路径前缀 ===
const THUMB_BASE = 'images/thumb/';     // 小图（爱心图云用）
const FULL_BASE = 'images/full1/';      // 原始大图
const STREAM_BASE = 'images/full2/';   // 新增：专为瀑布流优化的中等质量图

// 存储图片编号
const imageIds = [];
for (let i = 1; i <= 200; i++) {
  imageIds.push(i);
}

// === 新增：生成爱心图云用的图片索引数组（数量×3） ===
function generateHeartImageIndices() {
  const indices = [];
  const totalImages = imageIds.length;
  const multiplier = 5; // 重复4次
  
  // 方法1：简单重复4次
  for (let repeat = 0; repeat < multiplier; repeat++) {
    for (let i = 0; i < totalImages; i++) {
      indices.push(imageIds[i]);
    }
  }
  
  // 打乱顺序，让图片分布更随机
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [indices[i], indices[j]] = [indices[j], indices[i]];
  }
  
  return indices;
}

// 生成爱心图云用的图片索引（600个）
const heartImageIndices = generateHeartImageIndices();

// 生成带前导零的文件名
function formatImageName(id) {
  return id.toString().padStart(3, '0');
}

// Canvas初始化
const canvas = document.getElementById('heartCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth * 0.8;
canvas.height = window.innerHeight * 0.8;
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

// 状态：true=爱心，false=流式
let isHeart = true;

// === 新增：海浪效果相关变量 ===
let waveAnimationId = null;
let waveStartTime = 0;
let isWaveActive = false;
let waveProgress = 0; // 0到1之间，表示波浪进度
let lastWaveTime = 0; // 上次波浪开始时间

// 海浪效果参数配置
const waveConfig = {
  interval: 5000,       // 5秒一次
  duration: 2000,       // 波浪持续时间2秒
  amplitude: 15,        // 波浪振幅（像素）
  frequency: 0.03,      // 波浪频率
  speed: 0.8,           // 波浪传播速度
  color: 'rgba(255, 102, 255, 0.3)', // 波浪颜色
  showWaveLine: true,   // 是否显示波浪线
  waveEffect: true      // 是否启用波浪效果
};

// === 爱心坐标点缓存 ===
let heartPoints = null;

// === 修复：使用正确的爱心参数方程，支持垂直压缩 ===
function isPointInHeart(x, y, centerX, centerY, scale, verticalCompression = 0.8) {
  // 转换为爱心坐标系
  const tx = (x - centerX) / scale;
  const ty = (y - centerY) / (scale * verticalCompression); // 垂直方向应用压缩
  
  // 爱心参数方程 (x^2 + y^2 - 1)^3 - x^2 * y^3 <= 0
  const x2 = tx * tx;
  const y2 = ty * ty;
  const y3 = ty * y2;
  
  return Math.pow(x2 + y2 - 1, 3) - x2 * y3 <= 0;
}

// === 修复：生成爱心坐标函数 ===
function generateHeartPoints(count) {
  if (heartPoints && heartPoints.length === count) {
    return heartPoints; // 如果已经生成过，直接返回
  }
  
  const points = [];
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const scale = Math.min(canvas.width, canvas.height) * 0.4; // 自适应大小
  
  // 方法1：在爱心区域内均匀采样
  const attempts = count * 10; // 尝试次数
  const bounds = {
    minX: centerX - scale * 1.5,
    maxX: centerX + scale * 1.5,
    minY: centerY - scale * 1.5,
    maxY: centerY + scale * 1.5
  };
  
  // 生成内部点
  for (let i = 0; points.length < count && i < attempts; i++) {
    const x = bounds.minX + Math.random() * (bounds.maxX - bounds.minX);
    const y = bounds.minY + Math.random() * (bounds.maxY - bounds.minY);
    
    if (isPointInHeart(x, y, centerX, centerY, scale)) {
      // 添加轻微随机偏移，避免过于整齐
      const offsetX = (Math.random() - 0.5) * 5;
      const offsetY = (Math.random() - 0.5) * 5;
      // 垂直翻转：centerY - (y - centerY) = 2*centerY - y
      const flippedY = 2 * centerY - (y + offsetY); // 添加垂直翻转
      points.push({ 
        x: x + offsetX, 
        y: flippedY,
        originalY: flippedY, // 保存原始Y坐标
        originalX: x + offsetX // 保存原始X坐标
      });
    }
  }
  
  // 如果内部点不够，生成边界点
  if (points.length < count) {
    const remaining = count - points.length;
    
    // 使用参数方程生成爱心边界点
    for (let i = 0; i < remaining; i++) {
      const t = Math.random() * Math.PI * 2;
      
      // 爱心参数方程
      const x = 16 * Math.pow(Math.sin(t), 3);
      const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      
      // 缩放和平移
      const scaleFactor = scale / 20; // 调整缩放因子
      const px = centerX + x * scaleFactor;
      const py = centerY - y * scaleFactor; // 注意：这里用减号，因为爱心需要正过来
      
      points.push({ 
        x: px, 
        y: py,
        originalY: py,
        originalX: px
      });
    }
  }
  
  // 打乱顺序
  for (let i = points.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [points[i], points[j]] = [points[j], points[i]];
  }
  
  // 缓存结果
  heartPoints = points;
  return points;
}

// 存储已加载的图片
const loadedImages = new Map();

// === 新增：计算海浪偏移 ===
function calculateWaveOffset(point, currentTime) {
  if (!isWaveActive || !waveConfig.waveEffect) return 0;
  
  // 计算波浪进度（0到1）
  const elapsed = currentTime - waveStartTime;
  waveProgress = Math.min(elapsed / waveConfig.duration, 1);
  
  // 如果波浪已经结束
  if (waveProgress >= 1) {
    isWaveActive = false;
    return 0;
  }
  
  // 计算波浪当前位置（从上到下，0到1）
  const wavePosition = waveProgress * 1.2 - 0.1; // 稍微扩展范围，确保覆盖整个爱心
  
  // 计算该点相对于波浪位置的距离
  // 将点的y坐标归一化到0-1范围（从上到下）
  const normalizedY = 1 - (point.originalY / canvas.height);
  
  // 计算点到波浪前沿的距离
  const distanceToWave = normalizedY - wavePosition;
  
  // 如果点在波浪后面（已经经过），或者太远（还没到达），则没有偏移
  if (distanceToWave > 0.2 || distanceToWave < -0.1) {
    return 0;
  }
  
  // 使用正弦波计算偏移量
  // distanceToWave为负表示点在波浪前方，正值表示在波浪后方
  const waveOffset = Math.sin(
    -distanceToWave * Math.PI * 10 + // 波浪形状
    point.originalX * waveConfig.frequency + // 根据x坐标添加水平变化
    waveProgress * Math.PI * 2 * waveConfig.speed // 波浪随时间移动
  );
  
  // 应用衰减：越靠近波浪中心，影响越大
  const attenuation = Math.exp(-Math.abs(distanceToWave) * 10);
  
  // 应用波浪进度：波浪开始时和结束时振幅较小
  const progressFactor = 1 - Math.pow(2 * waveProgress - 1, 2); // 抛物线形状，中间高两边低
  
  return waveOffset * waveConfig.amplitude * attenuation * progressFactor;
}

// === 新增：绘制波浪线 ===
function drawWaveLine(currentTime) {
  if (!waveConfig.showWaveLine || !isWaveActive || !waveConfig.waveEffect) return;
  
  const elapsed = currentTime - waveStartTime;
  const progress = Math.min(elapsed / waveConfig.duration, 1);
  
  // 计算波浪线位置（从上到下）
  const waveY = progress * canvas.height * 1.2 - canvas.height * 0.1;
  
  // 如果波浪线在画布外，不绘制
  if (waveY < -10 || waveY > canvas.height + 10) return;
  
  ctx.save();
  
  // 绘制波浪线
  ctx.beginPath();
  ctx.moveTo(0, waveY);
  
  // 绘制波浪形状
  for (let x = 0; x <= canvas.width; x += 10) {
    const y = waveY + Math.sin(
      x * waveConfig.frequency * 0.5 + 
      progress * Math.PI * 2 * waveConfig.speed
    ) * 5;
    ctx.lineTo(x, y);
  }
  
  ctx.strokeStyle = waveConfig.color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // 绘制波浪线前端的光晕
  const gradient = ctx.createRadialGradient(
    canvas.width / 2, waveY, 0,
    canvas.width / 2, waveY, canvas.width / 3
  );
  gradient.addColorStop(0, 'rgba(64, 169, 255, 0.2)');
  gradient.addColorStop(1, 'rgba(64, 169, 255, 0)');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, waveY - 30, canvas.width, 60);
  
  ctx.restore();
}

// === 新增：启动波浪效果 ===
function startWave() {
  isWaveActive = true;
  waveStartTime = Date.now();
  waveProgress = 0;
  lastWaveTime = waveStartTime;
}

// === 修复：优化渲染函数 - 添加海浪效果 ===
function renderHeart() {
  const currentTime = Date.now();
  
  // 检查是否需要启动新的波浪（每5秒一次）
  if (!isWaveActive && waveConfig.waveEffect && currentTime - lastWaveTime > waveConfig.interval) {
    startWave();
  }
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 使用 heartImageIndices (600个) 而不是 imageIds (200个)
  const points = generateHeartPoints(heartImageIndices.length);
  
  // 绘制波浪线
  drawWaveLine(currentTime);
  
  // 绘制图片
  heartImageIndices.forEach((id, i) => {
    const point = points[i];
    if (!point) return;
    
    // 计算波浪偏移
    const waveOffset = calculateWaveOffset(point, currentTime);
    
    // 如果图片已加载，直接绘制
    if (loadedImages.has(id)) {
      const img = loadedImages.get(id);
      drawImageAtPoint(img, point, waveOffset);
    } else {
      // 异步加载图片
      const img = new Image();
      img.src = `${THUMB_BASE}${formatImageName(id)}.jpg`;
      img.onload = () => {
        loadedImages.set(id, img);
        drawImageAtPoint(img, point, waveOffset);
      };
      img.onerror = () => {
        console.warn(`图片加载失败: ${img.src}`);
        drawPlaceholder(point, waveOffset);
      };
    }
  });
  
  // 在爱心模式下，继续动画循环
  if (isHeart) {
    waveAnimationId = requestAnimationFrame(renderHeart);
  }
}

// 辅助函数：绘制图片到指定点（添加波浪偏移）
function drawImageAtPoint(img, point, waveOffset = 0) {
  // 爱心模式中图片稍小，因为数量变多了
  const maxWidth = 20; // 从30减小到20，因为图片更多了
  const scale = Math.min(maxWidth / img.width, 1);
  const drawWidth = img.width * scale;
  const drawHeight = img.height * scale;
  
  // 应用波浪偏移
  const yOffset = point.y + waveOffset;
  
  // 保存画布状态
  ctx.save();
  
  // 如果存在波浪偏移，添加轻微的颜色效果
  if (Math.abs(waveOffset) > 0.5 && waveConfig.waveEffect) {
    // 根据偏移方向添加蓝色或青色色调
    const hue = waveOffset > 0 ? 200 : 180; // 蓝色或青色
    const alpha = Math.min(Math.abs(waveOffset) / waveConfig.amplitude, 0.3);
    
    // 应用颜色叠加
    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
    ctx.fillRect(
      point.x - drawWidth / 2 - 2,
      yOffset - drawHeight / 2 - 2,
      drawWidth + 4,
      drawHeight + 4
    );
    
    // 恢复合成模式
    ctx.globalCompositeOperation = 'source-over';
  }
  
  // 绘制图片
  ctx.drawImage(
    img, 
    point.x - drawWidth / 2, 
    yOffset - drawHeight / 2, 
    drawWidth, 
    drawHeight
  );
  
  ctx.restore();
}

// 辅助函数：绘制占位符（添加波浪偏移）
function drawPlaceholder(point, waveOffset = 0) {
  const yOffset = point.y + waveOffset;
  ctx.fillStyle = '#eee';
  ctx.fillRect(point.x - 10, yOffset - 10, 20, 20);
  ctx.strokeStyle = '#ccc';
  ctx.strokeRect(point.x - 10, yOffset - 10, 20, 20);
}

// 预加载图片（可选，提高性能）
function preloadImages() {
  imageIds.forEach(id => {
    if (!loadedImages.has(id)) {
      // 爱心图云用小图
      const thumbImg = new Image();
      thumbImg.src = `${THUMB_BASE}${formatImageName(id)}.jpg`;
      thumbImg.onload = () => loadedImages.set(id, thumbImg);
      
      // 瀑布流用高质量图片（新增）
      // 如果你有STREAM_BASE目录下的优化图片，就用这个
      const streamImg = new Image();
      // 两种选择：
      // 1. 使用专为瀑布流优化的中等大小图片
      // streamImg.src = `${STREAM_BASE}${formatImageName(id)}.jpg`;
      // 2. 或者继续使用原始图片但加载时设置更高的质量
      streamImg.src = `${FULL_BASE}${formatImageName(id)}.jpg`;
      // 为streamImg添加一个标识，以便在瀑布流中使用
      streamImg._isForStream = true;
    }
  });
}

// 瀑布流渲染
let scrollOffset = 0;
const columnWidth = 300;
const gap = 10;
const columns = Math.floor(canvas.width / (columnWidth + gap));
let columnHeights = new Array(columns).fill(0);

function renderStream() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  columnHeights = new Array(columns).fill(0);

  const totalWidth = columns * columnWidth + (columns - 1) * gap;
  const startX = (canvas.width - totalWidth) / 2;

  // 重置滚动位置
  if (isHeart) {
    scrollOffset = 0;
  }

  // 瀑布流仍然使用原始的200张图片
  imageIds.forEach((id, i) => {
  // 优先使用瀑布流专用图片
  let img = loadedImages.get(`stream_${id}`);
  
  if (!img) {
    // 如果没有专用图片，使用原始图片
    img = loadedImages.get(id) || new Image();
    img.src = `${FULL_BASE}${formatImageName(id)}.jpg`;
    loadedImages.set(id, img);
  }
  
  if (img.complete && img.naturalHeight !== 0) {
    drawStreamImage(img, id, i, startX);
  } else {
    img.onload = () => {
      drawStreamImage(img, id, i, startX);
    };
  }
});
}

function drawStreamImage(img, id, index, startX) {
  const colIndex = index % columns;
  const x = startX + colIndex * (columnWidth + gap);
  const y = columnHeights[colIndex] + gap / 2;

  const scale = columnWidth / img.width;
  const drawWidth = Math.round(img.width * scale);
  const drawHeight = Math.round(img.height * scale);

  if (y + drawHeight > scrollOffset && y < scrollOffset + canvas.height) {
    // 启用高质量渲染
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    ctx.drawImage(
      img, 
      Math.round(x), 
      Math.round(y - scrollOffset), 
      drawWidth, 
      drawHeight
    );
  }

  columnHeights[colIndex] = y + drawHeight + gap / 2;
}

// 滚轮事件
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  if (!isHeart) {
    scrollOffset += e.deltaY * 0.5;
    if (scrollOffset < 0) scrollOffset = 0;
    
    // 限制最大滚动
    const maxScroll = Math.max(...columnHeights) - canvas.height;
    if (scrollOffset > maxScroll) scrollOffset = maxScroll;
    
    renderStream();
  }
});

// === 修改：点击切换 - 管理动画循环 ===
canvas.addEventListener('click', () => {
  isHeart = !isHeart;
  document.querySelector('.status').textContent = isHeart 
    ? '点击切换：爱心图云 ↔ 图片流' 
    : '点击恢复爱心图云';
  
  if (isHeart) {
    // 切换到爱心模式，开始动画循环（包含海浪效果）
    startHeartAnimation();
  } else {
    // 切换到瀑布流模式，停止动画循环
    stopHeartAnimation();
    renderStream();
  }
});

// 启动爱心动画（包含海浪效果）
function startHeartAnimation() {
  if (waveAnimationId) {
    cancelAnimationFrame(waveAnimationId);
  }
  
  // 初始化波浪效果
  waveStartTime = Date.now();
  lastWaveTime = waveStartTime - waveConfig.interval + 1000; // 1秒后开始第一次波浪
  
  // 开始动画循环
  waveAnimationId = requestAnimationFrame(renderHeart);
}

// 停止爱心动画
function stopHeartAnimation() {
  if (waveAnimationId) {
    cancelAnimationFrame(waveAnimationId);
    waveAnimationId = null;
  }
  isWaveActive = false;
}

// 窗口大小改变时重置
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth * 0.8;
  canvas.height = window.innerHeight * 0.8;
  
  // 清除爱心点缓存，因为画布大小改变了
  heartPoints = null;
  
  if (isHeart) {
    startHeartAnimation();
  } else {
    renderStream();
  }
});

// === 第三部分：主控制逻辑 ===
let dynamicHeartControl = null;

function switchToMainInterface() {
  // 停止动态爱心动画
  if (dynamicHeartControl) {
    dynamicHeartControl.stop();
  }
  
  // 淡出动态爱心画布
  const pinkboard = document.getElementById('pinkboard');
  pinkboard.style.transition = 'opacity 1s ease';
  pinkboard.style.opacity = '0';
  
  // 淡入主画布和状态文字
  setTimeout(() => {
    canvas.style.opacity = '1';
    document.querySelector('.status').style.opacity = '1';
    
    // 隐藏动态爱心画布
    pinkboard.style.display = 'none';
    
    // 启动爱心动画（包含海浪效果）
    startHeartAnimation();
  }, 500);
}

// 初始加载
window.onload = () => {
  // 启动动态爱心动画
  const pinkboard = document.getElementById('pinkboard');
  dynamicHeartControl = heartAnimation.start(pinkboard);
  
  // 在动态爱心显示期间预加载图片
  preloadImages();
  
  // 5秒后切换到主界面
  setTimeout(switchToMainInterface, 5000);
};
</script>
